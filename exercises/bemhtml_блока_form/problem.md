-------------------------------------------------------------------------------
**Задание**: Написать BEMHTML-шаблон для блока `form`. Из BEMJSON блока удалить ключи `js` и `tag`, затем добавить эти параметры в шаблоне.

-------------------------------------------------------------------------------

### Шаблонизатор BEMHTML

#### Декларативная шаблонизация

В Яндексе очень любят декларативность — не только в CSS, но и в шаблонах, и в JavaScript'е.

Как выглядит декларативность в CSS:

```css
.menu__item { display: inline-block; }
```

Для всех элементов `item` блока `menu` будет применен стиль `display: inline-block;`, т.е. мы декларируем, как должны быть обработаны наши DOM-узлы, отобранные по условию:

```
условие { тело шаблона }
```

Мы отбираем все узлы DOM-дерева, соответствующие условию, и применяем к ним тело шаблона.

Для декларативной шаблонизации в Яндексе написали свой шаблонизатор BEMHTML. Подробнее о его архитектуре можно узнать из статьи [Шаблонизация данных в bem-core](http://ru.bem.info/technology/bemhtml/current/templating/).

Пример декларативного шаблона на BEMHTML:

```js
block('menu').elem('item')(
    tag()('span')
);
```

Отбираются все блоки БЭМ-дерева, соответствующие нашим условиям, потом к ним применяется тело шаблона:

```
(условия)(тело шаблона)
```

BEMHTML написан на JavaScript. Его синтаксис — это чистый JavaScript, расширенный несколькими дополнительными ключевыми словами для описания БЭМ-сущностей. Можно использовать JavaScript-функции в подпредикатах и теле шаблона. Для production-режима шаблоны будут скомпилированы в оптимизированный JavaScript.

BEMHTML отвечает за то, как наше БЭМ-дерево преобразуется в HTML-строку. Входными данными является БЭМ-дерево или его фрагменты, описанные в технологии BEMJSON. На этот BEMJSON накладывается BEMHTML-шаблон. А выходные данные – HTML-строка.

В общем виде шаблон выглядит следующим образом:

```
match(подпредикат1, подпредикат2, подпредикат3)(тело);
```

Подпредикаты - это условия, которые должны выполниться для того, чтобы сработало тело шаблона. Например:

```js
match(this.block === 'link',  this._mode === 'tag', this.ctx.url)('a');
```

Этот шаблон проверяет, является ли текущий блок блоком `link`, есть ли в контексте `this.ctx` переменная `url`, и является ли текущая мода модой `tag`. При соблюдении всех этих условий к блоку будет применен тег `a`.

#### Мода

Мода — это шаг генерации выходного HTML. Каждая мода отвечает за свой кусочек получающегося HTML-кода.

Мода `default` описывает набор и порядок прохождения остальных мод. На этой схеме видно, за что отвечает каждая мода:

[Схема мод при генерации HTML](https://github.com/bem/bem-core/blob/v2/common.docs/reference/reference_mode_default.png)

Рекомендуем вдумчиво прочитать документацию по BEMHTML, описанную в [Cправочном руководстве по шаблонизатору BEMHTML](http://ru.bem.info/technology/bemhtml/current/reference/).

Напишем шаблоны наших блоков. Внимательно посмотрев на `index.bemjson.js`, вынесем повторяющиеся куски и фрагменты, относящиеся к конкретным блокам, в отдельные шаблоны.

Откроем нашу страницу: http://localhost:8080/desktop.bundles/index/

По окончанию процесса сборки запустим `node bfs-workshop.js verify` для тестирования результатов этого шага.
